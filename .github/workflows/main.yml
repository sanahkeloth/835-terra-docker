name: Deploy to ECR

on:
  push:
    branches: [master]

jobs:
  build:
    name: Build Image
    runs-on: ubuntu-latest

    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      AWS_REGION: us-east-1

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set aws_session_token ${{ secrets.AWS_SESSION_TOKEN }}
          aws configure set region us-east-1

      - name: Set up environment variables for repositories
        run: |
          echo "ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_MYSQL=mysql_image" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_APP=app_image" >> $GITHUB_ENV

      - name: Get Current Image Tag
        id: get-current-tag
        run: |
          CURRENT_TAG=$(aws ecr describe-images --repository-name $ECR_REPOSITORY_APP --query 'imageDetails |
          sort_by(@, &imagePushedAt)[-1].imageTags' --output text)
          if [[ -z "$CURRENT_TAG" || "$CURRENT_TAG" == "None" ]]; then
          CURRENT_TAG='v1.1.0'
          fi
          echo "CURRENT_TAG=$CURRENT_TAG" >> $GITHUB_ENV

      - name: Increment the version tag
        id: increment-version
        run: |
          # Split the version tag on the dot
          IFS='.' read -ra TAG_PARTS <<< "$CURRENT_TAG"
          MAJOR="${TAG_PARTS[0]}"
          MINOR="${TAG_PARTS[1]}"
          PATCH="${TAG_PARTS[2]}"
          # Increment the PATCH version
          PATCH=$(($PATCH + 1))
          NEW_TAG="$MAJOR.$MINOR.$PATCH"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV

      - name: Build, test, tag, and push mysql image to Amazon ECR
        run: |
          echo "Starting DB container..."
          docker build -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_MYSQL }}:$NEW_TAG -f Dockerfile_mysql .
          DBID=$(docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }} --name my_db ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_MYSQL }}:$NEW_TAG)
          
          echo "Waiting for MySQL to be ready..."
          until docker exec $DBID mysqladmin ping -h"localhost" --silent; do
            echo -n "."
            sleep 1
          done
          echo "MySQL is up and running!"

          DBHOST=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $DBID)
          echo "DBHOST=$DBHOST" >> $GITHUB_ENV
          echo "DBPORT=3306" >> $GITHUB_ENV

          docker build -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_APP }}:$NEW_TAG .

          echo "Starting webserver containers..."
          (docker run -p 8081:8080 -e DBHOST=$DBHOST -e DBPORT=$DBPORT -e APP_COLOR="blue" -d --name app_blue ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_APP }}:$NEW_TAG && echo "App1 started") &
          (docker run -p 8082:8080 -e DBHOST=$DBHOST -e DBPORT=$DBPORT -e APP_COLOR="pink" -d --name app_pink ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_APP }}:$NEW_TAG && echo "App2 started") &
          (docker run -p 8083:8080 -e DBHOST=$DBHOST -e DBPORT=$DBPORT -e APP_COLOR="lime" -d --name app_lime ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_APP }}:$NEW_TAG && echo "App3 started") &
          wait
          echo "All containers started!"
          sleep 30
          # Unit tests
          curl localhost:8081 -vvv
          curl localhost:8082 -vvv
          curl localhost:8083 -vvv
          
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_MYSQL:$NEW_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_APP:$NEW_TAG
